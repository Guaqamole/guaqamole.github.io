---
title: MySQL 아키텍처
author: guaqamole
date: 2023-01-19 18:32:00 +0900
categories: [DB, MySQL]
tags: [CS, Database, RDBMS, Indexing]
image:
  path: /common/mysql.png
---

이번 포스트에선 그동안 확실하게 짚고 넘어가고 싶었지만 너무 광범위한 주제여서 차마 시작하지 못했던 MySQL에 관한 글을 써보려고합니다. 이번 포스트는 인트로 느낌으로 간단하게 아키텍처 위주로 소개해보겠습니다.

<br>

****

**간단하게 짚고 넘어가는 MySQL의 역사**

1979년 MySQL은 스웨덴의 TcX라는 회사의 터미널 인터페이스로 제공하는 라이브러리 데이터베이스 UNIREG로 시작되었습니다. 1994년 UNIREG는 웹 시스템 데이터베이스로 TcX 회사 내에서 최초 MySQL 1.0을 사용하기 시작했고 MySQL은 1996년 대중에게 처음 공개되었습니다.

이후 2000년 TcX에서 MySQL을 개발한 몬티와 데이빗이 MySQL AB라는 회사로 독립하면서 FPL(Free Public License) 정책으로 바뀌었고 2006년엔 최종적으로 두 가지 라이센스 정책(MySQL 엔터프라이즈 버전, 커뮤니티 버전)으로 서비스를 시작하게되었습니다.

최종적으로 MySQL AB는 썬 마이크로시스템즈에게 인수되었고 몇년 후 썬마이크로시스템즈는 오라클에게 인수되어 현재 MySQL은 오라클이 관리하고 있는 오픈소스 RDBMS이죠.

<br>

## **MySQL 컴포넌트**

MySQL의 아키텍처를 설명한다면 크게 네가지 레이어로 나눠 설명할수 있을것같습니다.

![light mode only](/230819/1.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/1.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

### **Connection Client**

MySQL은 보시는 바와같이 대부분의 프로그래밍 언어에대해 Connection API를 제공합니다. 다양한 언어로 제공한다는건 접근성이 높아진다는 얘기겠죠? 뿐만아니라 저처럼 서버쟁이들이 선호하는 쉘스크립트로도 MySQL에 접근이 가능합니다. 

<br>

### **MySQL Engine (Core)**

> MYSQL 서버 = MYSQL 엔진 + 스토리지 엔진

이라고 할 수 있을 정도로 MySQL Engine은 MySQL에서 **두뇌**와 같은 중요한 역할을 담당합니다. 주로 클라이언트 접속 & SQL 요청을 처리하며, 네가지 파트로 나뉩니다.
<hr style="height:20px; visibility:hidden;" />
쿼리 파서
:  파서(`Parser`)가 들어온 쿼리 문장에 대해서 **문법(Syntax) 확인**을 하고 쿼리 문장을 적절한 단위로 분할하여 **파서 트리**(parser tree)를 만듭니다.

<hr style="height:20px; visibility:hidden;" />

전처리기
: 전처리기(`pre-processor`)가 앞에서 만들어진 **파서 트리**를 보고 **구조적으로 문제가 있는지 확인**합니다 (존재하지 않는 테이블 혹은 컬럼에 접근).

<hr style="height:20px; visibility:hidden;" />

옵티마이저
: 요청된 쿼리를 가장 적은 비용으로 빠르게 최적화 하기 위해 실행계획을 작성합니다.

<hr style="height:20px; visibility:hidden;" />

실행 엔진
: 옵티마이저에 의해 결정된 **실행 계획**대로 핸들러에게 지시합니다. (임시테이블 생성, where 조건에 따른 레코드 읽기등)

<hr style="height:20px; visibility:hidden;" />

### **Storage Engine (Core)**

MySQL 스토리지 엔진은 데이터를 실제로 디스크에 저장하거나 디스크에 저장된 데이터를 읽어오는 역할을 담당합니다. 

MySQL 엔진은 옵티마이저가 작성한 실행 계획에 따라서, 스토리지 엔진을 적절히 호출해서 쿼리를 실행하는데, 이때 스토리지를 호출 할 때 사용하는 API를 **핸들러 API**라고 합니다.

<br>

### **OS & Hardware**

실제 테이블의 데이터와 로그 데이터를 파일로 운영체제 저장하는 레이어입니다.

<br>

## **MySQL 스레드 구조**

> MySQL 스레드 = foreground thread + background thread

MySQL 서버는 멀티스레드 프로그램입니다. 다시말해, 서버로 요청이 들어올 때마다 배정되는 포그라운드 스레드도 있고 계속 돌고있는 백그라운드 스레드도 있다는 말입니다.
<hr style="height:20px; visibility:hidden;" />

- 포그라운드 스레드
  - 클라이언트/사용자가 요청한 쿼리 문장을 처리하는 스레드(고객 창구 역할)
  - 데이터 조회 스레드(데이터 버퍼나 캐시 또는 직접 디스크나 인덱스 파일로 접근하여 데이터를 가져오는 스레드)
- 백그라운드 스레드
  - Insert buffer를 병합하는 스레드
  - 로그 기록 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크로 기록(Write)하는 스레드
  - 데이터를 버퍼로 읽어들이는 스레드
  - 잠금, 데드락을 모니터링하는 스레드
  - 모든 백그라운드 스레드를 관리하는 메인 스레드

하지만 스레드를 사용한다고 무조건 성능이 좋아지진 않습니다. 반대로, 스레드가 너무 많아지면 성능이 떨어집니다.

갑자기 요청이 천개가 들어왔다고 해서 스레드를 천개나 만들어버리면, 컨텍스트 스위칭 관련 비용이 커져서 시스템 성능이 저하되죠. 

따라서, MySQL 뿐만 아니라 멀티스레드 프로그램들은 스레드 풀(thread pool)을 이용해서 스레드의 갯수를 제한 합니다.

### **스레드 풀의 원리**

![light mode only](/230819/11.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/11.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

서버는 요청이 들어올 때마다 새 스레드를 생성하는 대신, 스레드 풀에게 작업을 위임합니다.

스레드 풀은 놀고있는 스레드가 생기면 작업을 스레드에 할당하여 실행되도록 합니다:

1. 작업은 내부적으로 큐에 저장되며, 쓰레드 풀의 쓰레드들은 여기서 작업을 빼서 실행합니다. 
2. 큐에 새로운 작업이 들어오면 놀고 있는 쓰레드가 큐에서 작업을 빼서 실행합니다. 
3. 이것을 쓰레드에 작업이 할당되었다고 하며, 작업이 할당되지 않은 쓰레드들은 큐에 새 작업이 들어올 때까지 대기 상태로 유지됩니다.



예를들어, 스레드풀의 스레드 갯수를 10개로 정해놨다면, 갑자기 요청이 100개 들어왔을 때

처음 10개의 요청에 대해서는 스레드를 배정하고 나머지는 큐에다 넣어서 대기시킵니다.

<br>

## MySQL 메모리 구조

MySQL의 메모리 구조는 크게 글로벌 메모리 영역과 로컬(세션) 메모리 영역으로 나눠볼 수 있습니다.

**글로벌 영역은 많은 스레드에 의해 공유되는 영역**이고 **로컬 영역은 많은 스레드에 의해 공유되지 않는 독립적인 영역**입니다.

- 글로벌 메모리
  - MySQL 서버를 실행할 때 운영체제로부터 설정한 만큼 할당받는 영역
  - 모든 스레드로부터 공유되는 영역
- 로컬(세션) 메모리
  - 클라이언트 스레드가 쿼리를 처리하는데 쓰이는 영역
  - 스레드 별로 독립적이라 절대 공유되지 않는 영역
  - 쿼리의 용도 별로 할당이 될 때도 있고 아예 할당되지 않을 때도 있음

## **MySQL 쿼리 실행 과정**

![light mode only](/230819/2.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/2.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

### 1. 쿼리 캐시

사용자가 SQL 요청을 MySQL에 전달하게되면 **가장 먼저 만나게되는** 쿼리 캐시입니다. 

- SQL 실행 결과를 메모리에 캐싱
- 동일 SQL 실행시 이전 결과를 즉시 반환
- MySQL 5.x 버전의 경우 테이블의 데이터가 변경되면 캐싱된 데이터를 삭제해야 했었기 때문에 MySQL 8.0부터 미포함

이처럼 캐싱된 데이터가 삭제될때 마다 쿼리 캐시에 접근하는 쓰레드에 락이 걸리게되서 심각한 동시처리 성능저하가 발생했다고 합니다.

<hr style="height:20px; visibility:hidden;" />

### 2. 쿼리 파서

![](/230819/3.png){: .light .w-75 .shadow .rounded-10 width="600" height="500" }

기본적인 SQL 문장오류를 체크하며, 해당 문장을 토큰 단위로 쪼갠 다음에 트리로 만드는데 이 트리를 `Parse Tree`라고 합니다. MySQL은 내부적으로 Parse Tree를 사용해서 쿼리를 실행한다고 합니다.

- SQL 문장을 토큰으로 쪼개 트리로 만듦
- 트리로 만드는 과정에서 기본 문법 오류를 체크

<hr style="height:20px; visibility:hidden;" />

### 3. 전처리기

전처리기는 쿼리 파서가 만든 Parse Tree를 기반으로 쿼리문장에 구조적인 문제점이 있는지 검사합니다. 

전처리기의 동작 방식은 파스트리의 토큰을 하나씩 검사하면서 토큰에 해당하는 테이블 이름이나 컬럼등이 실제로 존재하는지 처리하고 접근권한에 대해서도 체크한다고 합니다.

<hr style="height:20px; visibility:hidden;" />

### 4. 옵티마이저

MySQL엔진의 꽃, 옵티마이저입니다. 옵티마이저는 SQL 실행을 최적화해서 실행 계획을 수립하죠. 

옵티마이저가 SQL을 최적화 하는 방법은 두가지가 있습니다:

규칙 기반 최적화
: 옵티마이저에 **내장된 우선순위**에 따라 실행 계획 수립

<hr style="height:20px; visibility:hidden;" />

비용 기반 최적화
: **작업의 비용**과 대상 **테이블의 통계 정보**를 활용해서 실행 계획 수립

<hr style="height:20px; visibility:hidden;" />

### 5. 쿼리 실행엔진

쿼리 실행 엔진은 옵티마이저가 만들어준 쿼리 실행 계획에 따라서 스토리지 엔진을 적절히 호출해서 쿼리를 실행하는 역할을 담당합니다.

<hr style="height:20px; visibility:hidden;" />

### 6. 스토리지 엔진

쿼리 실행 엔진이 요청한대로 데이터를 디스크에 저장하거나 디스크로부터 데이터를 읽어옵니다. 실행 엔진과 스토리지 엔진은 핸들러(핸들러 API)에 의해 서로 작동하고 플러그인 형태로 제공, 즉 사용자가 원하는 스토리지 엔진을 선택해서 사용할 수 있다는 말입니다.

MySQL 스토리지 엔진에는 대표적으로 두가지가 있습니다.

InnoDB
: 레코드 기반의 락(Lock)을 제공하며 이로 인해 높은 동시성 처리가 가능

MyISAM
: 가볍고 읽기가 빠른 스토리지 엔진 하지만 트랜잭션 기능의 지원 부재

MySQL 5.x 버전에선 스토리지 엔진 뿐만 아니라, 검색어 파서, 사용자 인증 모듈등 플러그인 형태로 제공했지만 서로 통신이 불가했고, 서버의 변수나 함수를 직접 호출하기 때문에 캡슐화를 위반한다는 단점이 있었다고 합니다.  따라서 MySQL 8 버전에선 **플러그인 아키텍처가 아닌, 컴포넌트 아키텍처**로 변경되었습니다.

<br>

## **스토리지 엔진**

### InnoDB

![light mode only](/230819/4.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/4.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }



프라이머리 키에 의한 클러스터링을 제공하고, 크게 메모리 영역과 디스크(스토리지) 영역으로 나눌 수 있습니다.

- 메모리 영역
  - **InnoDB 버퍼 풀** : 실제 데이터 블록(페이지)을 메모리에 적재하는 영역 + 인서트 버퍼 + 언두 레코드
  - **로그 버퍼** : 로그 스레드에 의해 로그 파일로 기록되기 전 버퍼링 하는 영역
- 디스크 영역
  - 시스템 테이블 스페이스
  - 사용자 테이블 스페이스
  - 리두(Redo) 로그

#### PK에 의한 클러스터링

쓰기 성능을 어느정도 포기하고 읽기 성능을 얻는 클러스터링.

- 레코드를 PK순으로 정렬해서 저장
- PK 인덱스 자동 생성
- PK를 통해서만 레코드에 접근 가능
- PK를 통한 범위 검색이 매우 빠름

<br>

#### 트랜잭션 MVCC

![light mode only](/230819/5.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/5.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

<hr style="height:20px; visibility:hidden;" />

InnoDB는 기본적으로 Commit, Rollback기능을 제공합니다.  InnoDB는 이 기능들과 MVCC를 활용해서 하나의 레코드에 대해 여러가지의 방식으로 트랜잭션 관리가 가능합니다. 쉽게 말해, 동시성 제어를 위해 `Lock`을 사용하지 않고, Undo 영역을 응용한다는것입니다. 

<hr style="height:20px; visibility:hidden;" />

![](/230819/6.png){: .light .w-75 .shadow .rounded-10 width="600" height="500" }

위 버퍼풀은 변경된 데이터를 디스크에 반영하기전까지 잠깐 버퍼링하는 공간을 의미하며,  언두 로그는 변경되기 이전 데이터를 백업해두는 공간입니다.

Undo Log
: 데이터 변경 전의 데이터를 백업

Redo Log
: 반영되지 않은 데이터 변경 내용을 백업 (MySQL Server가 강제 종료 되었을 때 실행)

<hr style="height:20px; visibility:hidden;" />

Buffer Pool
: 데이터나 인덱스 정보를 메모리에 캐시하거나 쓰기 작업을 일괄로 처리할 수 있게함 (일괄로 Buffer에 담아서 처리하면, 디스크 랜덤 액세스 횟수를 줄일 수 있음)

<br>

#### 트랜잭션의 동작 과정 예시

##### **READ_UNCOMMITED**

가장 낮은 격리 수준으로, **커밋하지 않은 데이터를 읽을 수 있습니다.**

만약, 트랜잭션 A가 데이터를 추가하고 트랜잭션 B가 이를 조회한다고 가정해 보겠습니다. 

트랜잭션 A를 처리하는 중 에러가 발생해 롤백해 버린다면, 트랜잭션 B는 올바르지 않은 데이터를 가져가는 것입니다.

![light mode only](/230819/7.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/7.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

위와 같이, 남자가 AGE를 30으로 수정하다 에러가 발생해서 롤백했습니다.

이 와중에 여자가 데이터를 조회하게 되면 테이블에 반영되어 있는 데이터를 그대로 가져옵니다.

이렇게 작업이 완료되지 않은 데이터(커밋이 되지 않은)를 조회하는 것을 DRITY READ라고 합니다.

에러가 발생해서 롤백되는 순간 데이터 정합성에 심각한 문제가 발생하는 것을 확인할 수 있습니다.

DIRTY READ가 허용되는 단계는 READ UNCOMMITED 단계뿐입니다.

<hr style="height:20px; visibility:hidden;" />

##### **READ_COMMITED**

DIRTY READ를 해결하기 위해, 격리 수준을 커밋된 데이터만 읽을 수 있도록 올린 단계입니다.

위 그림과 같은 상황에서 남자가 AGE를 30으로 수정해도, 커밋이 되지 않았기 때문에 여자는 0건의 데이터가 조회됩니다.

하지만, 여자의 트랜잭션이 진행되고 있을 때, 남자의 수정 쿼리가 커밋이 된다면 똑같은 쿼리를 사용하면 데이터를 얻을 수 있을 겁니다.

이렇게 한 트랜잭션 내에서 동일한 조회 쿼리를 사용했을 때, 같은 결과를 보장하지 않는 NON-REPEATABLE READ 문제가 발생합니다.

![light mode only](/230819/8.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/8.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

위 그림과 같이, 여자는 한 트랜잭션 내에서 동일한 쿼리를 사용했으나 다른 결과를 얻는 문제가 발생합니다.

이는 남자의 트랜잭션이 커밋되면서 수정된 데이터를 조회했기 때문입니다.

이렇게 DIRTY READ는 허용하지 않지만, NON-REPEATABLE READ는 허용하는 격리 수준이 READ COMMITTED입니다.

<hr style="height:20px; visibility:hidden;" />

##### **REPEATABLE_READ**

한 트랜잭션 내에서 조회한 데이터는 반복해서 조회해도 동일한 결과를 얻을 수 있는 격리 수준입니다.

이것이 가능한 이유는 UNDO 영역이 존재하기 때문입니다. 데이터를 수정하기 전, 테이블의 스냅샷을 UNDO 영역에 저장합니다.

트랜잭션 번호를 기준으로 번호가 더 낮은 트랜잭션이 들어오면, UNDO 영역에서 조회하게 됩니다.

따라서, 실제 테이블이 변경되어도 기존과 동일한 결과를 얻을 수 있는 것입니다.

![light mode only](/230819/9.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/9.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

위는 REPEATABLE READ 단계에서 NON_REPEATABLE READ를 방지하는 것을 나타낸 그림입니다.

트랜잭션 번호 5번을 가진 남자가 수정 쿼리를 전달하면, 기존 데이터를 UNDO 영역에 스냅샷을 저장합니다.

이후, 트랜잭션 번호 3번을 가진 여자가 AGE가 25 초과인 데이터를 조회하면, UNDO 영역에서 조회하기 때문에 0건의 데이터를 받습니다.

남자가 트랜잭션을 커밋하더라도, 여자는 여전히 UNDO영역에서 조회하기 때문에 동일한 결과를 얻을 수 있습니다.

<hr style="height:20px; visibility:hidden;" />

##### **SERIALIZABLE**

SERIALIZABLE은 제일 높은 격리 수준입니다.

트랜잭션에서 사용하는(읽고 쓰는) 데이터를 다른 트랜잭션에서 접근하지 못하게 막아 문제가 발생하지 않습니다.

접근을 못하니 읽고, 쓰는 것이 아예 불가능합니다.

따라서, DIRTY READ, NON-REPEATABLE READ모두 발생하지 않습니다.

이름 그대로 아예 직렬로 처리하는 것입니다. 당연히, 동시성 처리에 대한 **성능이 급격히 떨어지게 됩니다.**

<br>

### MyISAM

![light mode only](/230819/10.png){: .light .w-75 .shadow .rounded-50 w='800' h='600' }
![dark mode only](/230819/10.png){: .dark .w-75 .shadow .rounded-50 w='800' h='600' }

**`MyISAM`**은 **전체 문장 검색 능력, 고-성능 스토리지 및 복구 기능을 제공**합니다. 기본적으로 **비-트랜젝션-세이프(non-transactional-safe) 트랜잭션**이라고 하는데, 풀텍스트 인덱스를 지원해서  Read Only 기능이 많은 서비스일 수록 `MyISAM`이 효율적이라고 합니다. 하지만 InnoDB 처럼 **`row level locking`**을 지원하지않아 **`SELECT` `INSERT` `UPDATE` `DELETE`**시 **해당 Table 전체에 Locking**이 걸립니다.

따라서 **row의 수가 커지면 커질수록 CRUD 속도는 엄청나게 느려집니다.**

- 클러스터링 지원 X
- 트랜잭션 지원 X
- 외래키 지원 X
- 테이블 단위 잠금
- 키 캐시 사용 (인덱스 정보만 버퍼링)
- 전문 검색, 공간 좌표 검색 기능 지원

