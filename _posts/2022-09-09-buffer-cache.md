---
title: Buffers & Cache 그리고 가상 메모리
author: guaqamole
date: 2022-09-09 18:32:00 +0900
categories: [CS, OS]
tags: [Operating System, Kernel, Thread, TBE]
image:
  path: /common/linux.png
---

매번 서버에서 Running 중인 Application이 OOM 에러가 날때마다 버퍼와 캐시가 얼마나 메모리를 사용하고 있는지 `free -m` 으로 확인했었는데, 처음에는 버퍼와 캐시가 메모리를 너무 많이 사용하고 있어서 주기적으로 비워줘야한다고 생각했다.

사실 학부 이후로 운영체제에 대해 추가로 공부하지 않아서 학습이 더 필요하다고 생각했다.. 버퍼와 캐시를 제대로 이해하지못한 상태에서 운영을 하다보니 DB나 개발에서 자주 부딛히는 주제가 되서 "정리가 필요하다" 생각했다.

버퍼와 캐시는 운영체제에서 커널의 성능을 향상시키기 위해 사용하는 중요한 메커니즘이다. 버퍼와 캐시는 I/O 성능을 최적화하고 디스크 접근을 줄이는 데 중요한 역할을 합니다.

또한 가상 메모리는 운영체제의 핵심 구성 요소 중 하나로 오늘 주제에서 아주 중요한 개념인데요, 커널이 시스템 리소스를 관리하는 데 사용되죠. 가상 메모리는 메모리 주소 공간을 논리적으로 분할하고 페이지 교체 알고리즘을 사용하여 물리적 메모리에 대한 접근을 최적화합니다.

이러한 메커니즘은 주로 커널 모드에서 구현되지만 원리를 알지 못하면 유저 모드에서 활용 하기가 힘듭니다. 따라서 시스템 관리자 및 개발자가 성능 최적화를 위해 애플리케이션을 개발할 때 이 메커니즘들을 이해하는 것이 중요합니다.

<br>

****

# 가상 메모리의 역할

프로그램이 메모리에 적재되어 프로세스로 작동할 경우, 한 프로세스는 가상의 4GB 논리주소를 가지게 됩니다. 통상적으로 PC의 메모리는 8GB나 16GB이기 때문에 **여러 프로세스를 동시에 실행**하는 시스템의 경우, 메모리 용량 부족 이슈, 프로세스 메모리 영역 간 침범 이슈등으로 인해 가상 메모리를 필요로 하게됩니다.

> 프로세스가 4GB를 사용하는 이유는 32bit 시스템에서 2의 32 거듭제곱이 4GB이기 때문이다.
> {: .prompt-info }

![](/230109/1.png)
_Fig 1. 프로세스의 메모리 레이아웃_

위 자료를 보면 커널은 할당 받은 논리주소 4GB중에서 커널영역으로 1GB를, 사용자 영역에 3GB를 할당하여 사용하고 있습니다 (윈도우는 2G씩 사이 좋게 나눠쓴다하네요).

여기서 중요하게 봐야 할 사항은 사용자영역(User level)과 커널영역(Kernel level)로 나눠져 있으며 커널영역은 모든 프로세스가 공유하고 있다는 점이다. 이러한 구조 때문에 User Mode에서 Kernel level에 접근할 수가 없어서 주로 System call을 통해 Kernel mode를 호출하게 되죠.

**왜이렇게하나?**

Kernel level이 공유되어 있지 않고, 따로 존재한다면 어느 한 쪽의 프로세스에서 System call이 발생할 때마다 Context Switching이 일어나야 하므로 속도 측면에서 비효율적이다.

## 페이징 시스템 (Paging System)

하나의 프로세스에서 특정 시간 동안 쓰는 메모리 영역은 4GB 중 아주 일부분이기 때문에 일부분만 실제 물리 메모리에 올려놓고 쓰자는 것이 가상 메모리의 컨셉이다. 그럼 어느 정도의 사이즈만큼 메모리에 올릴 지에 대한 결정이 필요하겠죠?

이를 페이지(page)라는 단위로 다루겠다고 하는 것이 바로 **페이징 시스템**이다.

리눅스에서는 4KB 단위로 페이징하며 **페이지 번호를 기반**으로 **가상 주소와 물리 주소의 매핑 정보**를 기록하고 사용합니다. 즉, 4GB의 가상 메모리를 4KB 단위로 쪼개서 페이징하고 페이지 번호를 붙힌다는거죠.

![](/230109/2.png){: width="400" height="300" }
_Fig 2. 리눅스 페이징 시스템 예시_

정리하자면, CPU가 특정 가상 주소를 참조하게 되면, 그 가상 주소가 몇 페이지인 지를 알 수 있고 이를 통해 **Page Table**에서 해당 페이지의 실제 물리 메모리 주소를 알아낼 수 있습니다.
