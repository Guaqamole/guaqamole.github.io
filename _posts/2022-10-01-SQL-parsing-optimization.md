---
title: SQL 파싱과 최적화
author: guaqamole
date: 2022-10-01 18:32:00
categories: [DB, Tuning]
tags: [Tuning, Optimization, DBMS, SQL]
image:
  path: /common/oracle.png
---
SQL 튜닝을 본격적으로 시작하기에 앞서 옵티마이저가 SQL을 어떻게 처리하는지, 서버 프로세스는 데이터를 어떻게 읽고 저장하는지 이번 포스트에서 살펴보려고 합니다. DW 설계를 마치고 본격적으로 구축을 시작하기 전에 미리 튜닝 개념을 잡아놓고 싶었습니다. 앞으론 쿼리를 짤 때 어떤 관점으로 쿼리를 바라봐야하는지 개인적으로 공부하면 도움이 될거같아서 시작한 스터디이지만 마무리가 어떻게 될진 모르겠네요! 그래도 일단 SQL 튜닝의 세계로 여행을 떠나봅시다!

<br>

****

# SQL 정의

아래 두 테이블을 부서번호로 조인해서 사원명 순으로 정렬하는 로직을 떠올려봅시다.

![](/230413/1-1.jpeg){: width="800" height="600" }

~~~sql
SELECT E.EMPNO, E.ENAME, E.JOB, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
ORDER BY E.ENAME;
~~~

요즘에는 위와 같이 SQL로 간단히 처리 할 수 있었지만 20 ~ 30년 전만해도 이런 로직을 어렵게 프로그래밍으로 풀어냈다고 합니다..

## SQL이란?

Structured Query Language의 줄임말이며 말 그대로 `구조적 질의 언어`입니다. 위키피디아에서는 아래와 같이 정의하기도 합니다:

> SQL is **set-based, declartive query lanuage**, not an imperitive language such as C or BASIC.

원하는 결과집합을 구조적, 집합적으로 선언하지만 그 결과 집합을 만드는 과정은 절차적일 수 밖에 없습니다. 즉, 프로시저(Procedure)가 필요한데 그런 **프로시저를 만들어내는 DBMS 내부 엔진이 바로 SQL 옵티마이저입니다**. 옵티마이저가 프로그래밍을 대신해 주는 셈이죠.

![](/230413/1-2.jpeg){: width="800" height="600" }

<br>

# SQL 최적화

SQL을 실행하기 전 최적화 과정을 세분화하면 다음과 같다:

## 1. SQL Parsing

사용자로부터 SQL을 전달받으면 **가장 먼저 SQL Parser가 파싱을 진행**한다. SQL 파싱이란:

- 파싱 트리 생성: SQL문을 이루는 개별 구성요소를 분석해서 파싱트리 생성
- Syntax 체크: 문법적으로 오류가 없는지 확인 - 예시로, 사용 할 수 없는 키워드를 사용했거나, 순서가 바르지 않거나 누락된 키워드 확인
- Semantic 체크: 의미상 오류가 없는지 확인 - 예시로, 존재하지 않는 테이블 또는 컬럼을 사용했는지, 사용한 오브젝트에 대한 권한이 있는지 확인

## 2. SQL Optimization

그 다음으로 SQL 최적화는 옵티마이저가 수행한다. 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로는 생성해서 비교한후, 가장 효율적인 하나를 선택한다. 데이터베이스 성능을 결정하는 가장 핵심적인 엔진이다.

## 3. Generate Row Source

SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 **포맷팅하는 단계**입니다. Row Source Generator가 그 역할을 맡습니다.

<br>

# SQL 옵티마이저

SQL 옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 **최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심**입니다. 옵티마이저의 최적화 단계를 요약하면 아래와 같습니다.

![](/230413/1-3.png){: width="800" height="600" }

1. 사용자로부터 전달받은 쿼리를 수행하는데 후보군이 될만한 실행계획들을 찾아냅니다
2. 데이터 딕셔너리에 미리 수집해둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행 계획의 예상비용을 산정합니다
3. 최저비용을 나타내는 실행계획을 선택합니다.

## 실행 계획과 비용

**옵티마이저는 자동차 네비게이션과 흡사합니다**. 경로를 검색하고 나서 이동 경로를 미리 확인하는 기능이 있기 때문에 선택한 경로가 마음에 들지 않으면 이동 경로를 변경하거나, 경유지를 추가 해서 운전자가 원하는 경로로 바꿀 수 있습니다.

위와 같은 기능을 'SQL 실행경로 미리 보기'로 확인 할 수 있으며, **실행 계획(Execution Plan)**이라 합니다. 정확히 말하면 처리절차를 사용자가 확인 할 수 있게 아래와 같이 트리구조로 표현한것이 실행계획입니다.

![](/230413/1-3-1.png){: width="800" height="600" }

미리보기 기능을 통해 자신이 작성한 SQL이 테이블을 스캔하는지 인덱스를 스캔하는지도 확인 할 수 있으며, 내가 생각한 방향과 다르게 흘러가면 실행 경로를 변경 할 수 있다.

## 옵티마이저는 실행 계획을 어떻게 선택하나?

~~~sql
create table t as
	select d.no, e.*
	from HR.EMPLOYEES e, (select rownum AS no from dual connect by level <=1000) d;
~~~

# 소프트 파싱 vs 하드 파싱

DBMS 엔진은 요청받은 쿼리문을 실행하기 위해 파싱(Parsing)이라는 과정을 진행합니다. 이 파싱에는 문법 체크, 권한 유무, Library cache에 기존 쿼리가 있는지를 체크하는 공통 파싱 그리고 Library chace에 기존 쿼리가 있는 경우 진행하는 소프트 파싱(Soft parsing), 기존 쿼리가 없는 경우 진행하는 하드 파싱(Hard parsing) 총 3가지가 있습니다. 파싱을 설명하기 앞서 오라클 DB의 SGA에 대해 설명하겠습니다.

오라클에는 기본적으로 메모리 영역과 (SGA) / 데이터베이스 영역으로 나뉘어져 있습니다. 여기서 SGA (System Global Area)란, 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간을 말합니다.

![Desktop View](/230413/1-4-1.jpeg){: width="600" height="400"}

SQL을 수행 할 때 실행 계획이 바로 이 Library Cache 영역에 저장되어 사용됩니다.

## 라이브러리 캐시(Library Cache)

SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 말합니다.

- SGA(System Global Area) 구성요소
- 해시 구조 - SQL 쿼리마다 해시값을 매핑해서 저장하고 SQL 쿼리를 Library Cache에서 찾을 때는 SQL 문장을 해시 함수에 적용하여 반환 되는 해시값으로 탐색

## 소프트 파싱(soft parsing)

SQL 을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 말합니다.

- library cache에서 바로 꺼내서 사용함
- 같은 쿼리라도 줄바꿈, 대소문자, 공백에 변화가 있는경우에 완전 다른 sql로 간주하므로 **똑같은 텍스트로 sql을 짜는것이 중요함**
  ( 데이터베이스는 sql문장을 키값으로 인식함 )
- 동적인 쿼리를 날릴때에도 바인드 변수를 사용하면 됨. 바인드 변수를 제외한 나머지 쿼리를 파싱 한 다음 마지막에 바인드 변수를 적용하게되므로 가능

## 하드 파싱(hard parsing)

SQL 을 캐시에서 찾지 못하여 최적화 및 로우 소스 생성 단계를 모두 거치는 것을 말합니다.

- **Optimization :** 최적화한 쿼리 실행 계획 을 만듬
- **Row source generation :** DB엔진이 실행할 수 있는 프로그램 소스 생성

## 정리

![Desktop View](/230413/1-4-2.png){: width="600" height="400"}

<br>

# 바인드 변수

## 이름없는 SQL

- SQL은 이름이 없어, 전테 SQL텍스트가 이름 역할을 한다
- 따라서, 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 생성되는 구조이다

## 공유가능 SQL

- 의미가 같지만 텍스트가 다른 SQL은 실행할 때 각각 최적화를 실행하고 라이브러리 캐시에서 별도 공간을 사용한다
- 바인드 변수로 변수처리를 해주는 경우에는 SQL에 대한 하드 파싱은 최초 한번만 일어나고, 캐싱된 SQL을 사용하게 된다.



# SQL은 왜 느릴까?

일단 단도직입적으로 말하면 **디스크 I/O 때문입니다.** 디스크 I/O가 발생한다면 어떤 일들이 벌어질까요? 우선 OS 또는 I/O 서브 시스템이 I/O를 처리하는 동안 프로세스는 잠을 자게되고, **정확히 표현하자면 대기 상태에 빠집니다.** 

프로세스가 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 잠시 수면(Waiting) 상태에서 I/O가 완료되기를 기다립니다. 따라서 OS가 IO를 처리중이면 실행중인 프로세스는 interrupt로 인해 수시로 실행 준비 상태 ( Runnable Queue )로 전환했다가 다시 실행 상태로 전환하게 됩니다. 이런 이유 때문에 I/O가 많으면 성능이 저하 될 수 밖에 없으며, **우리의 역할은 I/O의 횟수를 최소화 하는것입니다.**

> I/O 튜닝이 곧 SQL 튜닝이라고 할 수 있습니다.

<br>

# 데이터 베이스 저장 구조

![Desktop View](/230413/1-11.png){: width="600" height="400"}
_Fig 2. DBMS Storage Architecure_

- **데이터 파일**: 디스크 상의 물리적인 OS파일

- **테이블 스페이스** : 세그먼트를 담는 컨테이너, 여러개의 데이터파일로 구성
- **세그먼트** : 데이터 저장공간이 필요한 오브젝트( 테이블, 인덱스, 파티션, LOB 등 )
  - 여러개의 익스텐트로 구성
  - 테이블,인덱스를 생성할 때 데이터를 어떤 테이블 스페이스에 저장할지를 지정한다.
  - 파티션 구조가 아니라면, 테이블/인덱스는 각각 하나의 세그먼트이다.
  - 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다
- **익스텐트** : 공간을 확장하는 단위, 연록된 블록들의 집합
  - 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로 부터 익스텐트를 추가로 할당 받는다
- **블록** : 데이터를 읽고 쓰는 단위
  - 사용자가 입력한 레코드를 실제로 저장하는 공간
  - 페이지 라고도 부름 ( DB2, SQL Server )
  - 한 블록은 한 테이블이 독점한다 → 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다.

## DBA ( Data Block Address )
데이터 블록은 자신만의 고유 주소값을 의미합니다. 즉, 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타냅니다.
인덱스를 이용해 테이블 레코드를 읽을 대는 인덱스 ROWID를 이용해야하며, ROWID 는 DBA + 로우번호(블록 내 순번, 로케이션)으로 구성되어 있습니다.

## 블록단위 I/O

DBMS가 데이터를 읽고 쓰는 단위 (데이터 I/O단위) : **블록**

→ 테이블, 인덱스에서 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽음

<br>

# 시퀀셜 액세스 vs 랜덤 액세스

테이블 또는 인덱스 블록을 액세스 하는 방식은 2가지가 있습니다.

## 시퀀셜 엑세스

- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식

- 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어 있으므로, 이 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다.

- 테이블의 경우 서로 논리적인 연결고리를 가지고 있지 않다

  ⇒ 세그먼트에 할당된 인트텐트 목록을 세그먼트 헤더에 맵(map)으로 관리한다, 익스텐트 맵은 각 익스텐스트이 첫 번째 블록 주소값을 갖는다

- 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫번째 블록뒤에 연속해서 저장된 블록을 순서대로 읽으면, 그것이 곧 **Full Table Scan**이다.

## 랜덤 엑세스

- 논리적, 물리적 순서를 다르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근함

<br>

# 논리적 I/O vs 물리적 I/O

이 둘을 설명하기 이전에 DB 버퍼캐시가 뭔지 알고가자!

## DB 버퍼 캐시

- 데이터 캐시, 디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 불록에 대한 반복적인 I/O Call을 줄이는 데 목적이 있다
- 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다

## 논리적 블록 I/O

- SQL 처리하는 과정에 발생한 총 블록 I/O
- 메모리상의 버퍼캐시를 경유하므로 메모리 I/O(전기적 신호) 와 동일

## 물리적 블록 I/O

- 디스크에서 발생한 총 블록 I/O
- 블록캐시에서 찾지 못한 경우 디스크 액세스하므로 논리적블록 I/O 중 일부를 물리적으로 I/O 한다.
- 디스크 I/O 는 물리적 작용이 일어나므로 굉장히 느리다.

## 버퍼캐시 히트율 (Buffer Cache Hit Ratio)

읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾는 비율을 말합니다.

~~~sql
BCHR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) x 100
= ( (논리적I/O - 물리적I/O) / 논리적I/O ) x 100
= ( 1 - (물리적I/O) / (논리적 I/O) ) x 100
~~~

따라서,`물리적 I/O = 논리적 I/O x ( 100 - BCHR )`

- SQL 성능을 높이기 위해서 할 수 있는 일은 **논리적 I/O를 줄이는 일뿐이다.**
- ⭐ **논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL튜닝이다.** ==> 매우중요!!
- BCHR이 높다고 해서 무조건 효율적인 SQL을 의미하지 않는다
  - 예) 같은 블록을 비효율적으로 반복해서 읽는 경우

<br>

# Single Block I/O vs Multi Block I/O

## Single Block I/O

한 번에 한 블록씩 요청해서 메모리에 적재하는 방법입니다.

- 인덱스를 이용할 때는 기본적으로는 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용
- 인덱스는 기본적으로 single 방식



## Multi Block I/O

한 번에 여러 블록씩 요청해서 메모리에 적재하는 방법입니다.

- 인덱스를 이용하지 않고 테이블을 전체 스캔할 때 사용
- 테이블이 클수록 Multi Block I/O 단위도 크면 좋다
- 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할 때 디스크 상에 그 블록과 인접한 블록들을 한번에 읽어 캐시에 미리 적재하는 기능
- 한번에 담는 양 : db_file_multiblock_read_count ( 보통 128 )

<br>

# Table Full Scan vs Table Range Scan

테이블 전체를 스캔하는 방식과 인덱스를 이용한 테이블 액세스 방식의 차이를 알아보겠습니다.

- Table Full Scan
  - 테이블에 속한 블록 전체를 읽는다
- Index Range Scan
  - 인덱스에서 일정량을 스캔하면서 얻는 ROWID(테이블 레코드가 디스크상 어디 저장되었는지) 로 테이블 레코드를 찾는다

<br>

# 캐시 탐색 메커니즘

- Direct Path I/O 를 제외한 모든 블록 I/O 는 메모리 버퍼캐시를 경유한다.
- 버퍼캐시는 해시 구조로 관리된다.
- 해시 알고리즘으로 버퍼 헤더를 찾고, 얻은 포인터로 버퍼 블록을 액세스한다.

## 메모리 공유자원에 대한 액세스 직렬화

- 버퍼캐시는 SGA 구성요소로 공유자원이다.
- 동시성의 문제가 존재한다.
- 한 프로세스씩 순차적 접근이 가능하도록 직렬화 메커니즘이 필요하다

## 래치(Latch)

버퍼 캐시에서 해시 체인을 탐색하면서 대량의 데이터를 읽는데, 그사이에 체인이 수정되면 안된다. 따라서 해시체인 래치가 존재하고 키를 획득한 프로세스만이 진입가능합니다.

- SGA 를 구성하는 서브 캐시마다 별도의 래치 존재
- 래치에 의한 경합이 높으면 성능 저하 발생
- 버퍼블록에도 직렬화 메커니즘이 존재한다 : 버퍼 Lock
- 결국 SQL 튜닝을 통해 쿼리 일량(논리적I/O)를 줄여야 한다
