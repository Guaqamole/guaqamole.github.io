---
title: 데이터 저장 구조 및 IO 메커니즘
author: avokey
date: 2023-04-10 09:32:00
categories: [DB, Tuning]
tags: [Tuning, Optimization, DBMS, SQL]
---
<br>![Desktop View](/common/dbms.jpg){: width="400" height="300"}
_Fig 1. DBMS_

# SQL은 왜 느릴까?

일단 단도직입적으로 말하면 **디스크 I/O 때문입니다.** 디스크 I/O가 발생한다면 어떤 일들이 벌어질까요? 우선 OS 또는 I/O 서브 시스템이 I/O를 처리하는 동안 프로세스는 잠을 자게되고, **정확히 표현하자면 대기 상태에 빠집니다.** 

프로세스가 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 잠시 수면(Waiting) 상태에서 I/O가 완료되기를 기다립니다. 따라서 OS가 IO를 처리중이면 실행중인 프로세스는 interrupt로 인해 수시로 실행 준비 상태 ( Runnable Queue )로 전환했다가 다시 실행 상태로 전환하게 됩니다. 이런 이유 때문에 I/O가 많으면 성능이 저하 될 수 밖에 없으며, **우리의 역할은 I/O의 횟수를 최소화 하는것입니다.**

> I/O 튜닝이 곧 SQL 튜닝이라고 할 수 있습니다.

<br>

# 데이터 베이스 저장 구조

![Desktop View](/230413/1-11.png){: width="600" height="400"}
_Fig 2. DBMS Storage Architecure_

- **데이터 파일**: 디스크 상의 물리적인 OS파일

- **테이블 스페이스** : 세그먼트를 담는 컨테이너, 여러개의 데이터파일로 구성
- **세그먼트** : 데이터 저장공간이 필요한 오브젝트( 테이블, 인덱스, 파티션, LOB 등 )
  - 여러개의 익스텐트로 구성
  - 테이블,인덱스를 생성할 때 데이터를 어떤 테이블 스페이스에 저장할지를 지정한다.
  - 파티션 구조가 아니라면, 테이블/인덱스는 각각 하나의 세그먼트이다.
  - 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다
- **익스텐트** : 공간을 확장하는 단위, 연록된 블록들의 집합
  - 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로 부터 익스텐트를 추가로 할당 받는다
- **블록** : 데이터를 읽고 쓰는 단위
  - 사용자가 입력한 레코드를 실제로 저장하는 공간
  - 페이지 라고도 부름 ( DB2, SQL Server )
  - 한 블록은 한 테이블이 독점한다 → 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다.

## DBA ( Data Block Address )
데이터 블록은 자신만의 고유 주소값을 의미합니다. 즉, 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타냅니다.
인덱스를 이용해 테이블 레코드를 읽을 대는 인덱스 ROWID를 이용해야하며, ROWID 는 DBA + 로우번호(블록 내 순번, 로케이션)으로 구성되어 있습니다.

## 블록단위 I/O

DBMS가 데이터를 읽고 쓰는 단위 (데이터 I/O단위) : **블록**

→ 테이블, 인덱스에서 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽음

<br>

# 시퀀셜 액세스 vs 랜덤 액세스

테이블 또는 인덱스 블록을 액세스 하는 방식은 2가지가 있습니다.

## 시퀀셜 엑세스

- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식

- 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어 있으므로, 이 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다.

- 테이블의 경우 서로 논리적인 연결고리를 가지고 있지 않다

  ⇒ 세그먼트에 할당된 인트텐트 목록을 세그먼트 헤더에 맵(map)으로 관리한다, 익스텐트 맵은 각 익스텐스트이 첫 번째 블록 주소값을 갖는다

- 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫번째 블록뒤에 연속해서 저장된 블록을 순서대로 읽으면, 그것이 곧 **Full Table Scan**이다.

## 랜덤 엑세스

- 논리적, 물리적 순서를 다르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근함

<br>

# 논리적 I/O vs 물리적 I/O

이 둘을 설명하기 이전에 DB 버퍼캐시가 뭔지 알고가자!

## DB 버퍼 캐시

- 데이터 캐시, 디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 불록에 대한 반복적인 I/O Call을 줄이는 데 목적이 있다
- 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다

## 논리적 블록 I/O

- SQL 처리하는 과정에 발생한 총 블록 I/O
- 메모리상의 버퍼캐시를 경유하므로 메모리 I/O(전기적 신호) 와 동일

## 물리적 블록 I/O

- 디스크에서 발생한 총 블록 I/O
- 블록캐시에서 찾지 못한 경우 디스크 액세스하므로 논리적블록 I/O 중 일부를 물리적으로 I/O 한다.
- 디스크 I/O 는 물리적 작용이 일어나므로 굉장히 느리다.

## 버퍼캐시 히트율 (Buffer Cache Hit Ratio)

읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾는 비율을 말합니다.

~~~sql
BCHR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) x 100
= ( (논리적I/O - 물리적I/O) / 논리적I/O ) x 100
= ( 1 - (물리적I/O) / (논리적 I/O) ) x 100
~~~

따라서,`물리적 I/O = 논리적 I/O x ( 100 - BCHR )`

- SQL 성능을 높이기 위해서 할 수 있는 일은 **논리적 I/O를 줄이는 일뿐이다.**
- ⭐ **논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL튜닝이다.** ==> 매우중요!!
- BCHR이 높다고 해서 무조건 효율적인 SQL을 의미하지 않는다
  - 예) 같은 블록을 비효율적으로 반복해서 읽는 경우

<br>

# Single Block I/O vs Multi Block I/O

## Single Block I/O

한 번에 한 블록씩 요청해서 메모리에 적재하는 방법입니다.

- 인덱스를 이용할 때는 기본적으로는 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용
- 인덱스는 기본적으로 single 방식



## Multi Block I/O

한 번에 여러 블록씩 요청해서 메모리에 적재하는 방법입니다.

- 인덱스를 이용하지 않고 테이블을 전체 스캔할 때 사용
- 테이블이 클수록 Multi Block I/O 단위도 크면 좋다
- 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할 때 디스크 상에 그 블록과 인접한 블록들을 한번에 읽어 캐시에 미리 적재하는 기능
- 한번에 담는 양 : db_file_multiblock_read_count ( 보통 128 )

<br>

# Table Full Scan vs Table Range Scan

테이블 전체를 스캔하는 방식과 인덱스를 이용한 테이블 액세스 방식의 차이를 알아보겠습니다.

- Table Full Scan
  - 테이블에 속한 블록 전체를 읽는다
- Index Range Scan
  - 인덱스에서 일정량을 스캔하면서 얻는 ROWID(테이블 레코드가 디스크상 어디 저장되었는지) 로 테이블 레코드를 찾는다

<br>

# 캐시 탐색 메커니즘

- Direct Path I/O 를 제외한 모든 블록 I/O 는 메모리 버퍼캐시를 경유한다.
- 버퍼캐시는 해시 구조로 관리된다.
- 해시 알고리즘으로 버퍼 헤더를 찾고, 얻은 포인터로 버퍼 블록을 액세스한다.

## 메모리 공유자원에 대한 액세스 직렬화

- 버퍼캐시는 SGA 구성요소로 공유자원이다.
- 동시성의 문제가 존재한다.
- 한 프로세스씩 순차적 접근이 가능하도록 직렬화 메커니즘이 필요하다

## 래치(Latch)

버퍼 캐시에서 해시 체인을 탐색하면서 대량의 데이터를 읽는데, 그사이에 체인이 수정되면 안된다. 따라서 해시체인 래치가 존재하고 키를 획득한 프로세스만이 진입가능합니다.

- SGA 를 구성하는 서브 캐시마다 별도의 래치 존재
- 래치에 의한 경합이 높으면 성능 저하 발생
- 버퍼블록에도 직렬화 메커니즘이 존재한다 : 버퍼 Lock
- 결국 SQL 튜닝을 통해 쿼리 일량(논리적I/O)를 줄여야 한다
